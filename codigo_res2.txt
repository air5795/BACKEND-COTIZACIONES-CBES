// 2 .- GUARDAR PLANILLA DE APORTES -------------------------------------------------------------------------------------------------------
async guardarPlanilla(data: any[], createPlanillaDto: CreatePlanillasAporteDto) {
  const { cod_patronal, gestion, mes, tipo_planilla, usuario_creacion, nombre_creacion } = createPlanillaDto;

  // üîÑ CREAR QUERY RUNNER PARA TRANSACCIONES
  const queryRunner = this.planillaRepo.manager.connection.createQueryRunner();
  await queryRunner.connect();
  await queryRunner.startTransaction();

  try {
    // ‚úÖ VALIDACIONES INICIALES (usando empresasService fuera de la transacci√≥n)
    const empresa = await this.empresasService.findByCodPatronal(cod_patronal);
    if (!empresa) {
      throw new BadRequestException('No se encontr√≥ una empresa con el c√≥digo patronal proporcionado');
    }

    const tipoEmpresa = empresa.tipo?.toUpperCase();
    if (!tipoEmpresa) {
      throw new BadRequestException('No se pudo determinar el tipo de empresa');
    }
    if (!['PA', 'AP', 'AV', 'VA'].includes(tipoEmpresa)) {
      throw new BadRequestException(`Tipo de empresa no v√°lido: ${tipoEmpresa}`);
    }

    const fechaPlanilla = new Date(`${gestion}-${mes.padStart(2, '0')}-01`);

    let planillaMensualExistente: PlanillasAporte | null = null;

    if (tipo_planilla === 'Planilla Adicional') {
      // Solo aceptamos adicionales si hay una mensual activa (estado = 1)
      planillaMensualExistente = await queryRunner.manager.findOne(PlanillasAporte, {
        where: {
          cod_patronal,
          fecha_planilla: fechaPlanilla,
          tipo_planilla: 'Mensual',
          estado: 1,
        },
      });

      if (!planillaMensualExistente) {
        throw new BadRequestException('Debe existir una planilla Mensual activa (estado = 1) antes de subir una Adicional.');
      }
    } else if (tipo_planilla === 'Mensual') {
      // Validaci√≥n para no duplicar planilla mensual (sin importar estado)
      planillaMensualExistente = await queryRunner.manager.findOne(PlanillasAporte, {
        where: {
          cod_patronal,
          fecha_planilla: fechaPlanilla,
          tipo_planilla: 'Mensual',
        },
      });

      if (planillaMensualExistente) {
        throw new BadRequestException('Ya existe una planilla Mensual para este mes y gesti√≥n.');
      }
    }

    // ‚úÖ MANTENER TU L√ìGICA DE C√ÅLCULOS (parseOrZero, totalImporte, etc.)
    const parseOrZero = (val: any): number => {
      if (val === null || val === undefined) return 0;
      if (typeof val === 'string') {
        const clean = val.replace(/\./g, '').replace(',', '.').trim();
        const parsed = parseFloat(clean);
        return isNaN(parsed) ? 0 : parsed;
      }
      if (typeof val === 'number') return val;
      return 0;
    };

    let totalImporte = 0;
    data.forEach((row, index) => {
      const haberBasico = parseOrZero(row['Haber B√°sico']);
      const bonoAntiguedad = parseOrZero(row['Bono de antig√ºedad']);
      const montoHorasExtra = parseOrZero(row['Monto horas extra']);
      const montoHorasExtraNocturnas = parseOrZero(row['Monto horas extra nocturnas']);
      const otrosBonosPagos = parseOrZero(row['Otros bonos y pagos']);

      const sumaFila = haberBasico + bonoAntiguedad + montoHorasExtra + montoHorasExtraNocturnas + otrosBonosPagos;

      if (isNaN(sumaFila)) {
        throw new BadRequestException(`Error al calcular total en la fila ${index + 1}: valores no num√©ricos`);
      }

      totalImporte += sumaFila;
    });

    let cotizacionTasa: number;
    if (tipoEmpresa === 'PA') {
      cotizacionTasa = parseFloat((totalImporte * 0.03).toFixed(6));
    } else {
      cotizacionTasa = parseFloat((totalImporte * 0.1).toFixed(6));
    }

    const trabajadoresUnicos = new Set(data.map(row => row['N√∫mero documento de identidad'])).size;
    const totalTrabaj = trabajadoresUnicos;

    console.log(`üìä Estad√≠sticas de guardado:
    - Registros totales: ${data.length}
    - Trabajadores √∫nicos: ${totalTrabaj}
    - Trabajadores con m√∫ltiples cargos: ${data.length - totalTrabaj}`);

    // ‚úÖ CREAR PLANILLA USANDO QUERY RUNNER
    const nuevaPlanilla = queryRunner.manager.create(PlanillasAporte, {
      cod_patronal,
      id_empresa: empresa.id_empresa,
      fecha_planilla: fechaPlanilla,
      tipo_planilla,
      total_importe: totalImporte,
      total_trabaj: totalTrabaj,
      estado: 0,
      fecha_declarada: null,
      mes,
      gestion,
      usuario_creacion,
      nombre_creacion,
      cotizacion_tasa: cotizacionTasa,
      id_planilla_origen: tipo_planilla === 'Planilla Adicional' ? planillaMensualExistente.id_planilla_aportes : null,
    });

    const planillaGuardada = await queryRunner.manager.save(nuevaPlanilla);

    // ‚úÖ MANTENER TU FUNCI√ìN parseExcelDate
    function parseExcelDate(value: any): string | undefined {
      if (!value) return undefined;
      
      if (typeof value === 'string') {
        const cleanValue = value.trim();
        if (cleanValue === '') return undefined;
        
        const parsedDate = moment(cleanValue, ['DD/MM/YYYY', 'YYYY-MM-DD', 'MM/DD/YYYY', 'DD-MM-YYYY'], true);
        if (parsedDate.isValid()) {
          return parsedDate.toISOString();
        }
        
        throw new BadRequestException(`Formato de fecha no v√°lido: "${cleanValue}"`);
      }

      if (typeof value === 'number' && !isNaN(value) && value > 0) {
        const date = new Date(1900, 0, value - 1);
        return isNaN(date.getTime()) ? undefined : date.toISOString();
      }

      return undefined;
    }

    // ‚úÖ L√ìGICA PARA PLANILLAS ADICIONALES (OPTIMIZADA)
    let nroBase = 1;

    if (tipo_planilla === 'Planilla Adicional') {
      // üöÄ CONSULTA OPTIMIZADA para encontrar el m√°ximo n√∫mero
      const maxNroResult = await queryRunner.manager
        .createQueryBuilder()
        .select('MAX(detalle.nro)', 'max')
        .from(PlanillaAportesDetalles, 'detalle')
        .innerJoin(PlanillasAporte, 'planilla', 'planilla.id_planilla_aportes = detalle.id_planilla_aportes')
        .where('(planilla.id_planilla_aportes = :planillaId OR planilla.id_planilla_origen = :planillaId)', 
          { planillaId: planillaMensualExistente.id_planilla_aportes })
        .getRawOne();

      nroBase = (parseInt(maxNroResult?.max || '0', 10) || 0) + 1;
    }

    // ‚úÖ PREPARAR DETALLES (mantener tu l√≥gica)
    const detalles: CreatePlanillaAportesDetallesDto[] = data.map((row, index) => {
      const redondear = (valor: any): number => parseFloat(parseOrZero(valor).toFixed(6));
      const haberBasico = redondear(row['Haber B√°sico']);
      const bonoAntiguedad = redondear(row['Bono de antig√ºedad']);
      const montoHorasExtra = redondear(row['Monto horas extra']);
      const montoHorasExtraNocturnas = redondear(row['Monto horas extra nocturnas']);
      const otrosBonosPagos = redondear(row['Otros bonos y pagos']);

      return {
        id_planilla_aportes: planillaGuardada.id_planilla_aportes,
        nro: tipo_planilla === 'Mensual' ? index + 1 : nroBase + index,
        ci: row['N√∫mero documento de identidad']?.toString(),
        apellido_paterno: row['Apellido Paterno']?.toString(),
        apellido_materno: row['Apellido Materno']?.toString(),
        nombres: row['Nombres']?.toString(),
        sexo: row['Sexo (M/F)']?.toString(),
        cargo: row['Cargo']?.toString(),
        fecha_nac: parseExcelDate(row['Fecha de nacimiento']),
        fecha_ingreso: parseExcelDate(row['Fecha de ingreso']),
        fecha_retiro: parseExcelDate(row['Fecha de retiro']),
        dias_pagados: parseInt(row['D√≠as pagados'] || '0', 10) || null,
        haber_basico: haberBasico,
        bono_antiguedad: bonoAntiguedad,
        monto_horas_extra: montoHorasExtra,
        monto_horas_extra_nocturnas: montoHorasExtraNocturnas,
        otros_bonos_pagos: otrosBonosPagos,
        salario: parseFloat((haberBasico + bonoAntiguedad + montoHorasExtra + montoHorasExtraNocturnas + otrosBonosPagos).toFixed(6)),
        regional: row['regional']?.toString(),
        tipo: tipo_planilla.toLowerCase().replace(' ', '_') as 'mensual' | 'planilla_adicional',
      };
    });

    // üöÄ GUARDAR DETALLES EN LOTES USANDO QUERY RUNNER
    const batchSize = 1000;
    console.log(`üíæ Iniciando guardado de ${detalles.length} detalles en lotes de ${batchSize}...`);
    
    for (let i = 0; i < detalles.length; i += batchSize) {
      const batch = detalles.slice(i, i + batchSize);
      const batchNumber = Math.floor(i / batchSize) + 1;
      const totalBatches = Math.ceil(detalles.length / batchSize);
      
      console.log(`üì¶ Procesando lote ${batchNumber}/${totalBatches} (${batch.length} registros)...`);
      
      // Crear entidades y guardar con query runner
      const detalleEntities = batch.map(detalle => 
        queryRunner.manager.create(PlanillaAportesDetalles, detalle)
      );
      
      await queryRunner.manager.save(detalleEntities);
    }

    // ‚úÖ COMMIT DE LA TRANSACCI√ìN
    await queryRunner.commitTransaction();
    
    console.log(`‚úÖ Planilla guardada exitosamente con ${detalles.length} detalles`);

    return {
      mensaje: '‚úÖ Planilla guardada con √©xito',
      id_planilla: planillaGuardada.id_planilla_aportes,
      estadisticas: {
        total_registros: detalles.length,
        trabajadores_unicos: totalTrabaj,
        total_importe: totalImporte,
        lotes_procesados: Math.ceil(detalles.length / batchSize)
      }
    };

  } catch (error) {
    // üîÑ ROLLBACK EN CASO DE ERROR
    console.error('‚ùå Error en guardarPlanilla, haciendo rollback:', error.message);
    await queryRunner.rollbackTransaction();
    throw error;
  } finally {
    // üîÑ LIBERAR QUERY RUNNER
    await queryRunner.release();
  }
}